# -*- coding: utf-8 -*-
"""Google Stock Neural Net.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZQ0wNuSyxlc7a1RadvBKhrhmmBc6gCYD
"""

import pandas as pd
import numpy as np
import tensorflow as tf
from keras.layers import Dense,Flatten,Dropout,LSTM
from keras.models import Sequential
from keras.callbacks import CSVLogger
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split as tts
from tqdm import tqdm_notebook
import os
from sklearn.externals import joblib
import pickle
import matplotlib.pyplot as plt

train_data = pd.read_csv('Datasets/Google_Stock_Price_Train.csv')
test_data = pd.read_csv('Datasets/Google_Stock_Price_Test.csv')
test_data

def process(data):
    data = data.drop(['Date'],axis=1) 
    close = data['Close']
    volume = data['Volume']
    new_close = []
    new_volume = []
    for string in close:
        if(type(string) == float):
            new_close.append(string)
            continue
        val=[]
        for i in string:
            if(i!=','):
                val.append(i)
        new_close.append(float(''.join(val)))

    for string in volume:
        val=[]
        for i in string:
            if(i!=','):
                val.append(i)
        new_volume.append(int(''.join(val)))
    data['Close'] = pd.Series(new_close)
    data['Volume'] = pd.Series(new_volume)

    train_cols = ["Open","High","Low","Close","Volume"]
    x = data.loc[:,train_cols].values
    sc = MinMaxScaler(feature_range = (0, 1))
    x_train = sc.fit_transform(x)
    scalerfile = 'scaler.sav'
    pickle.dump(sc, open(scalerfile, 'wb'))
    return x_train

x_train = process(train_data)
x_test = process(test_data)

TIME_STEPS = 2
BATCH_SIZE = 4
def build_timeseries(mat, y_col_index):
    # y_col_index is the index of column that would act as output column
    # total number of time-series samples would be len(mat) - TIME_STEPS
    dim_0 = mat.shape[0] - TIME_STEPS
    dim_1 = mat.shape[1]
    x = np.zeros((dim_0, TIME_STEPS, dim_1))
    y = np.zeros((dim_0,))

    for i in range(dim_0):
        x[i] = mat[i:TIME_STEPS+i]

        y[i] = mat[TIME_STEPS+i, y_col_index]
    print("length of time-series i/o",x.shape,y.shape)
    return x, y

def trim_dataset(mat, batch_size):
    """
    trims dataset to a size that's divisible by BATCH_SIZE
    """
    no_of_rows_drop = mat.shape[0]%batch_size
    if(no_of_rows_drop > 0):
        return mat[:-no_of_rows_drop]
    else:
        return mat

x_t, y_t = build_timeseries(x_train, 3)
x_t_t,x_val,y_t_t,y_val = tts(x_t,y_t,test_size = 0.2)
x_t_t = trim_dataset(x_t_t, BATCH_SIZE)
y_t_t = trim_dataset(y_t_t, BATCH_SIZE)
x_val = trim_dataset(x_val, BATCH_SIZE)
y_val = trim_dataset(y_val, BATCH_SIZE)
x_test_t, y_test_t = build_timeseries(x_test, 3)
x_test_t = trim_dataset(x_test_t,BATCH_SIZE)
y_test_t = trim_dataset(y_test_t,BATCH_SIZE)

x_val

lstm_model = Sequential()
lstm_model.add(LSTM(100, batch_input_shape=(BATCH_SIZE, TIME_STEPS, x_t_t.shape[2]),
                        dropout=0.0, recurrent_dropout=0.0, stateful=True, return_sequences=True,
                        kernel_initializer='random_uniform'))
lstm_model.add(Dropout(0.5))
lstm_model.add(LSTM(60, dropout=0.0))
lstm_model.add(Dropout(0.4))
lstm_model.add(Dense(20,activation='relu'))
lstm_model.add(Dense(1,activation='linear'))
lstm_model.compile(loss='mean_squared_error', optimizer='adam')

#csv_logger = CSVLogger(os.path.join(OUTPUT_PATH, 'your_log_name' + '.log'), append=True)

lstm_model.fit(x_t_t, y_t_t, epochs=10, verbose=1, batch_size=BATCH_SIZE,
                    shuffle=False, validation_data=(trim_dataset(x_val, BATCH_SIZE),
                    trim_dataset(y_val, BATCH_SIZE)),workers=-1)

preds =lstm_model.predict(x_test_t,batch_size = BATCH_SIZE,verbose=1)

predictions=[]
for i in preds:
    predictions.append(i[0])
predicted_stock_price = pd.Series(predictions)
predicted_stock_price

x_test_df = pd.DataFrame(x_test[0:16])
real_stock_price = x_test_df[3]

scalerfile = 'scaler.sav'
sc= pickle.load(open(scalerfile, 'rb'))
pred_org = (predicted_stock_price*sc.data_range_[3])+sc.data_min_[3]
actual_org = (real_stock_price*sc.data_range_[3])+sc.data_min_[3]
pred_org

plt.plot(pred_org, color = 'black', label = 'Actual Stock Price')
plt.plot(actual_org, color = 'green', label = 'Predicted Google Stock Price')
plt.title('Google Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Stock Price')
plt.legend()
plt.show()

